<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 3363ef31-09e5-409a-a6d3-f8a4f8ea311a (2026-01-05 07:56Z) -->

# React 底层原理与源码学习 (2026-01-05 07:56Z)

_**User (2026-01-05 02:39Z)**_

我是一名高级前端开发工程师，现在想要系统的学习react的底层原理，切换Guided Learning模式，带领我结合源码进行学习

---

_**Agent (model gemini-3-flash-preview, mode Ask)**_

<think><details><summary>Thought Process</summary>
**Investigating React's Core**

I'm starting by exploring the React repository to get a lay of the land. My focus is on the codebase structure and identifying the key files and folders related to core functionality, trying to build a high-level understanding of the architecture first. I will then analyze the relevant implementation details.


**Discovering Package Contents**

I'm now examining the `packages` directory to get a grasp of the React repository's layout. My aim is to identify the crucial components and understand their relationships. I noted `react-reconciler` and `react-dom` previously, so I'll examine the remaining package names next.


</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Defining the Scope**

I'm now focusing on how to guide a senior engineer through React's internals. My plan begins with a clear overview: First, I'll tackle the mounting and initialization phases of the code. This will be the first step in understanding the React source code.


**Charting the Course**

I've scoped out the React internals exploration. The repo confirms React 18/19 compatibility. My teaching strategy includes mounting, Fiber architecture, reconciliation, scheduling, state management, and commit phases. I will be looking at `ReactDOMRoot.js` within `packages/react-dom` as a starting point.


</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-dom/src/client/ReactDOMRoot.js</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Defining Entry Points**

I've located the core entry points: `createRoot` and `render` within `ReactDOMRoot.js`. Now, my focus is shifting towards constructing a clear plan for the user, starting with an overview of the architecture, then a deep dive into the mounting phase.


**Planning the Presentation**

I've sketched out the high-level plan, and I'm ready to begin explaining it. I'll kick things off by outlining React's initialization process and Fiber architecture, which sets the stage for everything that follows. I'm focusing on ensuring each phase is clearly explained, aiming for a smooth flow through the rendering, committing, and scheduling aspects.


</details></think>

---

你好！很高兴能以 **Guided Learning** 模式带领你深入 React 的底层原理。作为一名高级前端工程师，你一定不满足于仅仅会用 API，而是希望理解其背后的设计思想、数据结构以及复杂的调度算法。

我们将采用**“由表及里、循序渐进”**的策略，结合你手头的 React 源码仓库进行深度拆解。

### 学习路线图 (Learning Path)

我们将整个学习过程分为以下五个核心阶段：

1.  **Phase 1: 初始化与 Fiber 架构 (The Foundation)** - 理解 React 如何从 `createRoot` 开始，以及 Fiber 这种核心数据结构的由来。
2.  **Phase 2: Render 阶段 (Reconciliation)** - 深入 `diff` 算法、`beginWork` 和 `completeWork`，理解双缓存机制。
3.  **Phase 3: Commit 阶段 (Side Effects)** - 学习 React 如何将内存中的 Fiber 树映射到真实的 DOM。
4.  **Phase 4: Scheduler 与并发模式 (Scheduling)** - 探讨 React 的优先级调度机制、时间分片 (Time Slicing)。
5.  **Phase 5: Hooks 机制与状态更新 (State Management)** - 拆解 `useState`、`useEffect` 的底层链表实现。

---

### 第一站：应用启动与 Fiber 根节点的创建

一切的起点都在 `react-dom`。当你调用 `createRoot(container).render(<App />)` 时，React 内部发生了什么？

请打开以下文件，这是我们探索的起点：
`packages/react-dom/src/client/ReactDOMRoot.js`

#### 关键代码导读

在 `createRoot` 函数中（约 171 行），你会看到它调用了 `createContainer`：

```171:249:packages/react-dom/src/client/ReactDOMRoot.js
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions,
): RootType {
  // ... 省略参数检查 ...

  const root = createContainer(
    container,
    ConcurrentRoot,
    null,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    onDefaultTransitionIndicator,
    transitionCallbacks,
  );
  // ...
  return new ReactDOMRoot(root);
}
```

#### 你的第一个挑战
1.  **寻找 `createContainer`**: 请尝试在源码中找到 `createContainer` 的具体定义。提示：它在 `react-reconciler` 包中。
2.  **理解 `FiberRoot` vs `RootFiber`**: 在 `createContainer` 执行后，React 会创建两个非常关键的对象。一个是全局唯一的 `FiberRootNode`，另一个是组件树的根节点 `HostRoot` (即第一个 Fiber 节点)。

**思考题：** 为什么要设计这两个不同的“根”对象？它们分别承担了什么职责？

---

**下一步建议：**
如果你准备好了，我们可以一起深入 `packages/react-reconciler/src/ReactFiberReconciler.js` 来查看 `createContainer` 的实现，并揭开 Fiber 对象的神秘面纱。

你可以告诉我：“我已经看到 `createContainer` 了，请继续介绍 Fiber 对象。” 或者提出你对目前启动流程的任何疑问。

---

_**User (2026-01-05 02:39Z)**_

继续

---

_**Agent (model gemini-3-flash-preview, mode Ask)**_

<think><details><summary>Thought Process</summary>
**Examining React Internals**

I've been drilling down into React's core. My focus shifted from the entry point, `createRoot`, towards the inner workings of `createContainer`. I'm now wrestling with understanding how React sets up the initial container for rendering and the subsequent implications for component management.


**Investigating createContainer Implementation**

Okay, I've located `createContainer` within `ReactFiberReconciler.js`, and its implementation is starting to make sense. My attention is now on dissecting the relationship between `FiberRootNode` and `RootFiber`. I'm starting to see how these elements are fundamental in orchestrating the reconciliation process. Next, I need to understand `Fiber` node structure.


</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberReconciler.js</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Analyzing Function Signatures**

I'm currently focused on the `createContainer` function signature. I've noted its presence in the output, specifically around line 250 in `ReactFiberReconciler.js`, but I need more context. I'm going to scan the lines preceding that point to get the complete picture before I can move on.


**Revising Contextual Analysis**

I'm correcting a slight misstep. Initially, I noted `createContainer`'s presence starting around line 250, but the preceding `read_file` call started at 260. I need to widen my scope to include the lines before 260 to ensure I get the full signature, so I'm shifting to reviewing the lines immediately before 260 to gain complete understanding.


</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberReconciler.js</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Searching for the Definition**

I'm currently trying to locate the definition of `createContainer`. I must have overlooked it. My plan now is to use `grep` to search for the function using the specific syntax `export function createContainer`. Hopefully, this will lead me to the source.


</details></think>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "export function createContainer" • 8 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./gemini-conversation.md` | `"pattern": "export function createContainer",` | L382 |
| `./gemini-conversation.md` | `"output": "Found 1 match for pattern \"export function createContainer\" in path \"packages/react-reconciler\":\n---\nFile: src/ReactFiberReconciler.js\nL236: export function createContainer(\n---"` | L398 |
| `./gemini-conversation.md` | `"output": "\nIMPORTANT: The file content has been truncated.\nStatus: Showing lines 231-330 of 918 total lines.\nAction: To read more of the file, you can use the 'offset' and 'limit' parameters in a subsequent 'read_file' call. For example, to read the next section of the file, use offset: 330.\n\n--- FILE CONTENT (truncated) ---\n    return getPublicInstance(hostFiber.stateNode);\n  \}\n  return findHostInstance(component);\n\}\n\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrationCallbacks: null \| SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  // TODO: Remove `concurrentUpdatesByDefaultOverride`. It is now ignored.\n  concurrentUpdatesByDefaultOverride: null \| boolean,\n  identifierPrefix: string,\n  onUncaughtError: (\n    error: mixed,\n    errorInfo: \{+componentStack?: ?string\},\n  ) => void,\n  onCaughtError: (\n    error: mixed,\n    errorInfo: \{\n      +componentStack?: ?string,\n      +errorBoundary?: ?component(...props: an [... omitted end of long line]` | L552 |
| `./gemini-conversation-1767599008995.json` | `"pattern": "export function createContainer",` | L127 |
| `./gemini-conversation-1767599008995.json` | `"output": "Found 1 match for pattern \"export function createContainer\" in path \"packages/react-reconciler\":\n---\nFile: src/ReactFiberReconciler.js\nL236: export function createContainer(\n---"` | L142 |
| `./gemini-conversation-1767599008995.json` | `"output": "\nIMPORTANT: The file content has been truncated.\nStatus: Showing lines 231-330 of 918 total lines.\nAction: To read more of the file, you can use the 'offset' and 'limit' parameters in a subsequent 'read_file' call. For example, to read the next section of the file, use offset: 330.\n\n--- FILE CONTENT (truncated) ---\n    return getPublicInstance(hostFiber.stateNode);\n  \}\n  return findHostInstance(component);\n\}\n\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrationCallbacks: null \| SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  // TODO: Remove `concurrentUpdatesByDefaultOverride`. It is now ignored.\n  concurrentUpdatesByDefaultOverride: null \| boolean,\n  identifierPrefix: string,\n  onUncaughtError: (\n    error: mixed,\n    errorInfo: \{+componentStack?: ?string\},\n  ) => void,\n  onCaughtError: (\n    error: mixed,\n    errorInfo: \{\n      +componentStack?: ?string,\n      +errorBoundary?: ?component(...p [... omitted end of long line]` | L239 |
| `./packages/react-reconciler/src/ReactFiberReconciler.js` | `export function createContainer(` | L236 |
| `./packages/react-native-renderer/src/ReactFiberConfigFabric.js` | `export function createContainerChildSet(): ChildSet \{` | L530 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating the Root**

I'm now diving into `createFiberRoot`, which `createContainer` calls. The file is `ReactFiberRoot.js`. This is where the core setup for a React application's structure begins. I'm keen to understand how the root is initialized and what data structures are involved.


**Examining Container Creation**

I've pinpointed the call to `createFiberRoot` within `createContainer`. Specifically, it's initiated at line 236. The next step is scrutinizing `createFiberRoot` itself within `ReactFiberRoot.js` to understand its role in establishing the application's foundational structure.


</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberRoot.js</summary>

</details>
</tool-use>

---

太棒了！我们现在进入了 React 架构的核心地带。

在 `packages/react-reconciler/src/ReactFiberRoot.js` 中，你可以看到 `createFiberRoot` 函数的实现。这是理解 React 树结构的关键。

### 1. 核心数据结构：FiberRootNode 与 HostRootFiber

在 `createFiberRoot` 中，React 完成了“双根”结构的建立：

```188:213:packages/react-reconciler/src/ReactFiberRoot.js
export function createFiberRoot(
  // ... 参数 ...
): FiberRoot {
  // 1. 创建 FiberRootNode
  const root: FiberRoot = (new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    onDefaultTransitionIndicator,
    formState,
  ): any);
  // ...

  // 2. 创建 HostRootFiber (即 uninitializedFiber)
  const uninitializedFiber = createHostRootFiber(tag, isStrictMode);

  // 3. 建立双向引用
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  // ...
```

#### 它们分别是什么？
- **`FiberRootNode` (root)**: 它是整个应用的**管理器**。它不属于 Fiber 树的一部分，而是记录了整个应用的更新信息、优先级、挂起的任务、调度信息等全局状态。
- **`HostRootFiber` (uninitializedFiber)**: 它是 Fiber 树的**根节点**。它是 Fiber 类型的一个实例。在 React 运行过程中，它代表了 `<div id="root">` 对应的 Fiber 节点。

**为什么要这么设计？**
这种“解耦”设计让 React 能够：
1.  **保存全局状态**: `FiberRootNode` 可以在多次渲染（多次 Fiber 树切换）之间持久存在。
2.  **支持双缓存 (Double Buffering)**: `root.current` 可以指向当前的 Fiber 树，而在后台构建另一棵 Fiber 树（workInProgress）。

---

### 2. 什么是 Fiber？

现在，让我们揭开 Fiber 节点的真面目。请看 `packages/react-reconciler/src/ReactFiber.js` 中的 `FiberNode` 定义。

你会发现 Fiber 节点本质上是一个 JavaScript 对象，承载了多种职责：

1.  **作为静态数据结构**: 存储了组件的类型 (`type`)、DOM 节点 (`stateNode`)、Props 和 State 等信息。
2.  **作为动态执行单元**: 包含 `return` (父)、`child` (第一个子)、`sibling` (下一个兄弟) 指针，构建了一棵可以随时中断并恢复的**链表树**。
3.  **作为调度单位**: 包含 `lanes` (优先级)、`flags` (副作用标记) 等。

```67:100:packages/react-reconciler/src/ReactFiber.js
function FiberNode(
  this: $FlowFixMe,
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // Instance
  this.tag = tag;          // 节点类型（FunctionComponent, HostComponent等）
  this.key = key;
  this.elementType = null;
  this.type = null;        // 组件对应的类或函数
  this.stateNode = null;   // 对应的真实 DOM 节点或 FiberRoot

  // Fiber 树结构（链表实现）
  this.return = null;      // 指向父节点
  this.child = null;       // 指向第一个子节点
  this.sibling = null;     // 指向右边第一个兄弟节点
  this.index = 0;

  this.ref = null;
  this.refCleanup = null;

  // 状态与更新
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // Effects (副作用标记)
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  // ...
```

### 3. 下一阶段：Render 阶段的起点

当我们调用 `root.render(<App />)` 时，实际上是调用了 `updateContainer`。

```135:135:packages/react-dom/src/client/ReactDOMRoot.js
    updateContainer(children, root, null, null);
```

#### 你的下一个探索任务：
在 `packages/react-reconciler/src/ReactFiberReconciler.js` 中找到 `updateContainer`。
重点关注它是如何创建一个 **Update** 并将其加入到 `updateQueue` 中的。

**提示：** 你会看到 `requestUpdateLane`（获取任务优先级）和 `scheduleUpdateOnFiber`（开始调度更新）。

准备好进入 `updateContainer` 的内部了吗？

---

_**User (2026-01-05 02:39Z)**_

为什么FiberRootNode 与 HostRootFiber要建立双向引用

---

_**Agent (model gemini-3-pro-preview, mode Ask)**_

这是一个非常深入且触及核心架构设计的问题！

`FiberRootNode` 和 `HostRootFiber` 之间的双向引用（循环引用），是 React 实现 **Double Buffering（双缓存）** 机制以支持并发渲染和快速回退的基础。

我们来具体拆解一下这种设计的原因：

### 1. 结构回顾

-   **`FiberRootNode` (`root`)**:
    -   代表整个应用的**根对象**，也是全局唯一的管理者。
    -   保存了调度的元数据：优先级 (Lanes)、挂起任务、错误信息等。
    -   它**不随着渲染而改变**，是一个持久存在的容器。
    -   `root.current`: 始终指向当前**已渲染在屏幕上**的那棵 Fiber 树的根节点。

-   **`HostRootFiber` (`root.current`)**:
    -   代表 Fiber 树的**根节点**。
    -   它是组件树的实际入口。
    -   每次渲染（更新）时，React 可能会在内存中构建一个新的 `HostRootFiber`（作为 `workInProgress` 树的一部分），或者复用旧的。
    -   `fiber.stateNode`: 指向所属的 `FiberRootNode`，方便在任意 Fiber 节点中通过 `return` 向上遍历找到根容器。

### 2. 为什么要双向引用？

#### A. 从 `FiberRootNode` 到 `HostRootFiber` (`root.current`)
这是为了**管理当前状态**。
React 需要知道当前屏幕上显示的是哪一棵树。
- 当 React 开始一次更新时，它会基于 `root.current` 克隆出一个 `workInProgress` 树。
- 当更新完成（commit 阶段），React 只需要做一个简单的指针切换：
  ```javascript
  root.current = workInProgressRoot;
  ```
  这瞬间就完成了整个应用状态的切换。这就好比显卡的双缓存技术：先在后台缓冲区绘制好下一帧，然后直接交换指针，避免屏幕闪烁。

#### B. 从 `HostRootFiber` 到 `FiberRootNode` (`fiber.stateNode`)
这是为了**让组件树能访问全局调度信息**。
任何一个组件（Fiber 节点）在触发更新时（例如调用 `setState`），都需要通知调度器。
- 组件只知道自己 (`this`)，它需要一种方式找到整个应用的“大脑” (`FiberRootNode`)。
- 只有找到了 `FiberRootNode`，才能：
    1.  计算当前更新的优先级（Lanes）。
    2.  将这个优先级“冒泡”标记到根节点，告诉 React “这棵树里有部分区域需要更新”。
    3.  通过 `Scheduler` 发起调度。

代码证据：当你调用 `setState` 时，React 内部会调用 `markUpdateLaneFromFiberToRoot`，它就是通过 `fiber.return` 一路向上找到 `HostRootFiber`，最后通过 `hostRootFiber.stateNode` 拿到 `FiberRootNode`。

### 3. 图解关系

```mermaid
graph TD
    FR[FiberRootNode<br/>(全局唯一，持久存在)]
    CR[Current HostRootFiber<br/>(当前屏幕显示的树根)]
    WIP[WorkInProgress HostRootFiber<br/>(正在构建的新树根)]

    FR -- current --> CR
    CR -- stateNode --> FR
    WIP -- stateNode --> FR
    CR -- alternate --> WIP
    WIP -- alternate --> CR

    subgraph "Commit 阶段切换"
    direction TB
    FR -.-> WIP
    end
```

### 总结
这种**双向引用**是 React 实现灵活调度的关键：
1.  **向下 (`root.current`)**: 支持双缓存，实现无缝的 UI 切换和并发渲染的中断/恢复。
2.  **向上 (`fiber.stateNode`)**: 让深层组件能够触发全局更新，并将更新请求传递给调度中心。

你觉得这个解释清楚吗？如果理解了这一点，我们就可以继续往下看 `updateContainer` 是如何利用这种结构来调度更新的了。

---

_**User (2026-01-05 02:39Z)**_

继续

---

_**Agent (model gemini-3-pro-preview, mode Ask)**_

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberReconciler.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberReconciler.js</summary>

</details>
</tool-use>

---

我们继续探究 `updateContainer` 的实现。这是 `root.render(<App />)` 被调用时发生的关键步骤。

在 `packages/react-reconciler/src/ReactFiberReconciler.js` 中，`updateContainer` 实际上是一个非常薄的包装层，它立即调用了 `updateContainerImpl`。让我们把目光集中在 `updateContainerImpl` 上，看看它做了哪三件大事：

### 1. 确定优先级 (Lane)

```javascript
// updateContainer
const lane = requestUpdateLane(current);
```
React 首先需要决定这次更新的“紧急程度”。`requestUpdateLane` 会根据当前的上下文（比如是在点击事件中，还是网络请求回调中）计算出一个 Lane（优先级）。对于 `root.render` 来说，通常是默认优先级。

### 2. 创建并封装 Update 对象

这是 `updateContainerImpl` 的核心逻辑（约 436 行）：

```javascript
  const update = createUpdate(lane);
  // Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload = {element}; // 这里的 element 就是你的 <App />
```

这里创建了一个 `Update` 对象。`Update` 是 React 中最小的更新单元。
-   **`payload`**: 对于 HostRoot 来说，payload 就是用户传入的 React 元素（`<App />`）。
-   这实际上是在告诉 React：“嘿，根节点的最新状态应该是这个 `<App />`。”

### 3. 加入队列并调度 (Enqueue & Schedule)

接下来，React 将这个更新加入到根节点的更新队列中，并通知调度器开始工作（约 455 行）：

```javascript
  const root = enqueueUpdate(rootFiber, update, lane);
  if (root !== null) {
    scheduleUpdateOnFiber(root, rootFiber, lane);
    // ...
  }
```

-   **`enqueueUpdate`**: 这是一个非常重要的函数（在 `ReactFiberClassUpdateQueue.js` 中）。它会将 update 对象挂载到 `rootFiber.updateQueue` 上。这是一个环形链表结构。
-   **`scheduleUpdateOnFiber`**: 这就是我们之前提到的“冒泡”过程。它会从 `rootFiber` 开始（虽然这里已经是根了，但对于普通组件也是一样的逻辑），标记路径上所有节点的 `lanes`，最终触发 `ensureRootIsScheduled`。

---

### 下一站：调度与开始渲染

`scheduleUpdateOnFiber` 是连接 React 业务逻辑和 Scheduler 调度器的桥梁。

**思考题：**
如果我在短时间内连续调用三次 `root.render`（或者在一个组件里连续调用三次 `setState`），会发生什么？
1.  会创建三个 Update 对象吗？
2.  会触发三次完整的 DOM 更新吗？

为了回答这个问题，我们需要看看 `scheduleUpdateOnFiber` 到底做了什么。

**你的下一步探索：**
请确认是否要深入 `scheduleUpdateOnFiber`，看看它是如何处理优先级的？或者你想先了解一下 `UpdateQueue` 是如何管理这些 Update 对象的？

---

_**User (2026-01-05 02:39Z)**_

继续

---

_**Agent (model gemini-3-pro-preview, mode Ask)**_

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function enqueueUpdate" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` | L156-233 |
| `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` | L467-531 |
| `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` | L82-155 |
| `packages/react-reconciler/src/ReactFiberConcurrentUpdates.js` | L108-168 |
| `packages/react-reconciler/src/ReactFiberConcurrentUpdates.js` | L44-113 |
| `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` | L420-476 |
| `packages/react-reconciler/src/ReactFiberClassComponent.js` | L128-219 |
| `packages/react-reconciler/src/ReactFiberHooks.js` | L146-220 |
| `packages/react-reconciler/src/ReactFiberHooks.js` | L3763-3868 |
| `packages/react-reconciler/src/ReactFiberHooks.js` | L3628-3696 |
| `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` | L230-277 |
| `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` | L271-310 |
| `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` | L87 |
| `packages/react-reconciler/src/ReactFiberReconciler.js` | L796-862 |
| `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` | L600-651 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberClassUpdateQueue.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberConcurrentUpdates.js</summary>

</details>
</tool-use>

---

我们现在已经找到了 `enqueueUpdate`，它藏在 `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` 和 `packages/react-reconciler/src/ReactFiberConcurrentUpdates.js` 中。

这里有一个非常重要的细节：React 的更新队列机制在近期版本中发生了变化，引入了**并发队列 (Concurrent Queue)** 的概念。

### 1. 传统的 `enqueueUpdate` (同步/Legacy)
在 `ReactFiberClassUpdateQueue.js` 中，你可以看到如果判定为 `isUnsafeClassRenderPhaseUpdate`（不安全的类组件渲染阶段更新），它会直接修改 `sharedQueue.pending` 环形链表。

```javascript
// ReactFiberClassUpdateQueue.js
const pending = sharedQueue.pending;
if (pending === null) {
  update.next = update;
} else {
  update.next = pending.next;
  pending.next = update;
}
sharedQueue.pending = update;
```
这是一个标准的环形链表插入操作。

### 2. 并发模式下的 `enqueueUpdate` (Concurrent)
但是，对于绝大多数情况（包括 `createRoot`），React 实际上调用的是 `enqueueConcurrentClassUpdate`，进而调用 `ReactFiberConcurrentUpdates.js` 中的 `enqueueUpdate`。

```javascript
// ReactFiberConcurrentUpdates.js
function enqueueUpdate(fiber, queue, update, lane) {
  // ...
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  // ...
  fiber.lanes = mergeLanes(fiber.lanes, lane);
}
```

**惊人发现：**
这里的 `enqueueUpdate` **并没有立即把 update 加到 fiber 的 updateQueue 里！**
相反，它只是把 update 暂时存放在一个全局数组 `concurrentQueues` 中。

**为什么？**
这是为了支持**并发渲染**。在并发模式下，React 可能正在渲染一棵树（WorkInProgress）。如果此时插入一个新的 Update 到队列中，可能会破坏正在进行的渲染或者导致状态不一致。
所以，React 采用了一种“暂存”策略：
1.  先把 update 扔到一个全局的“暂存区”。
2.  等到真正要开始下一次渲染或者处理副作用时，再统一把这些暂存的 update “刷入”到各自 Fiber 的真实 `updateQueue` 中。

这个“刷入”的操作由 `finishQueueingConcurrentUpdates` 函数完成。

### 回答之前的思考题

> 如果我在短时间内连续调用三次 `root.render`（或者在一个组件里连续调用三次 `setState`），会发生什么？

**答案揭晓：**

1.  **会创建三个 Update 对象吗？**
    **是**。每次调用 `root.render` 都会调用 `createUpdate` 创建一个新的对象。

2.  **会触发三次完整的 DOM 更新吗？**
    **通常不会**（取决于优先级）。
    React 会进行**批处理 (Batching)**。
    -   这三个 update 会被依次放入 updateQueue（或者暂存区）。
    -   React 调度器会合并它们。因为它们的优先级通常相同，React 只会发起一次调度。
    -   在接下来的 Render 阶段，React 会遍历 updateQueue，计算出最终的 State。
        -   Update1: `<App prop="A" />` -> State: A
        -   Update2: `<App prop="B" />` -> State: B
        -   Update3: `<App prop="C" />` -> State: C
    -   最终，React 只会根据最后的状态 C 进行一次 DOM 更新。

---

### 下一步：从调度到渲染

我们已经把 update 放入队列了，接下来就是“发动机”点火的时候了。

在 `updateContainerImpl` 的最后：
```javascript
scheduleUpdateOnFiber(root, rootFiber, lane);
```

这将引导我们走向 React 的心脏——**Scheduler (调度器)** 和 **WorkLoop (工作循环)**。

你想深入研究 `scheduleUpdateOnFiber` 怎么把任务交给 Scheduler，还是直接跳到 `beginWork` 看组件是如何被渲染的？

---

_**User (2026-01-05 02:39Z)**_

继续学习

---

_**Agent (model gemini-3-pro-preview, mode Ask)**_

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function scheduleUpdateOnFiber" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactFiberReconciler.js` | L796-862 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L851-1321 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L891-1321 |
| `packages/react-reconciler/src/ReactFiberClassComponent.js` | L66 |
| `packages/react-reconciler/src/ReactFiberReconciler.js` | L245-458 |
| `packages/react-reconciler/src/ReactFiberHooks.js` | L146-220 |
| `packages/react-reconciler/src/ReactFiberHooks.js` | L81-149 |
| `packages/react-reconciler/src/ReactFiberReconciler.js` | L67-120 |
| `packages/react-reconciler/src/ReactFiberClassComponent.js` | L128-219 |
| `packages/react-reconciler/src/ReactFiberClassUpdateQueue.js` | L156-233 |
| `packages/react-reconciler/src/ReactFiberHotReloading.js` | L241-332 |
| `packages/react-reconciler/src/ReactFiberConcurrentUpdates.js` | L247-286 |
| `packages/react-reconciler/src/ReactFiberClassComponent.js` | L213-525 |
| `packages/react-reconciler/src/ReactFiberCompleteWork.js` | L161-205 |
| `packages/react-reconciler/src/ReactFiberReconciler.js` | L484-630 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberWorkLoop.js</summary>

</details>
</tool-use>

---

我们在 `packages/react-reconciler/src/ReactFiberWorkLoop.js` 中找到了 `scheduleUpdateOnFiber`。这是 React 调度更新的入口。

### 深入 `scheduleUpdateOnFiber`

这个函数的核心职责是将更新“注册”到根节点，并请求调度器开始工作。

#### 1. 标记根节点有更新 (`markRootUpdated`)
```javascript
  // Mark that the root has a pending update.
  markRootUpdated(root, lane);
```
这一步非常关键。它会把当前的 `lane`（优先级）合并到 `root.pendingLanes` 中。这意味着 React 知道了：“哦，现在有一个优先级为 X 的任务需要处理。”

#### 2. 处理渲染中的更新 (Interleaved Updates)
如果当前已经在渲染了（`root === workInProgressRoot`），但又来了一个新的更新（比如用户在渲染过程中点击了按钮）：
```javascript
    if (root === workInProgressRoot) {
      // ...
      if ((executionContext & RenderContext) === NoContext) {
        workInProgressRootInterleavedUpdatedLanes = mergeLanes(
          workInProgressRootInterleavedUpdatedLanes,
          lane,
        );
      }
      // 如果当前的渲染已经挂起（suspended），这个新更新可能会打断它，
      // 让 React 重新评估是否应该放弃挂起，转而处理这个新更新。
    }
```

#### 3. 确保根节点被调度 (`ensureRootIsScheduled`)
这是最重要的部分：
```javascript
    ensureRootIsScheduled(root);
```
不管发生了什么，React 最后都会调用 `ensureRootIsScheduled`。这个函数是 Scheduler 和 Reconciler 的交汇点。它的逻辑非常精妙：

1.  **检查现有任务**：如果有正在进行的任务，先看看它的优先级。
2.  **计算新任务优先级**：根据 `root.pendingLanes` 计算出最高优先级的任务。
3.  **决策**：
    -   如果新任务优先级 **低于** 正在进行的任务 -> **啥也不做**（让现有任务继续）。
    -   如果新任务优先级 **高于** 正在进行的任务 -> **取消现有任务**，调度新任务。
    -   如果优先级 **相同** -> **复用现有任务**。

---

### Phase 1 总结 & Phase 2 预告

恭喜你！我们已经完成了 **Phase 1: 初始化与 Fiber 架构** 的核心路径探索。

我们回顾一下这趟旅程：
1.  `createRoot` -> 创建了 `FiberRootNode` (全局管理者) 和 `HostRootFiber` (组件树根)。
2.  `root.render` -> 创建了 `Update` 对象 (包含 `<App />`)。
3.  `enqueueUpdate` -> 将 Update 放入并发队列 (Concurrent Queue) 暂存。
4.  `scheduleUpdateOnFiber` -> 将更新优先级标记到 `FiberRoot`，并请求调度。

接下来，我们将进入激动人心的 **Phase 2: Render 阶段 (Reconciliation)**。

在下一阶段，我们将解答：
1.  React 是如何从 `ensureRootIsScheduled` 真正开始执行代码的？(`performConcurrentWorkOnRoot`)
2.  **WorkLoop** 是怎么运转的？
3.  **BeginWork**: 组件是如何被调用（执行）的？`diff` 算法在哪里发生？
4.  **CompleteWork**: DOM 节点是什么时候创建的？

**准备好了吗？**
请告诉我“进入 Phase 2”，我们将从 `ensureRootIsScheduled` 内部的调度逻辑开始，追踪到 `workLoop` 的启动。

---

_**User (2026-01-05 18:46Z)**_

继续学习

---

_**Agent (model gemini-3-pro-preview, mode Ask)**_

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function ensureRootIsScheduled" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L109-168 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L115-174 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L65-151 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L891-1321 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L256-347 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L4144-4382 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L4602-4671 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L248-347 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L1781-2166 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L72 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L640-722 |
| `packages/react-reconciler/src/ReactFiberDevToolsHook.js` | L49-151 |
| `packages/react-reconciler/src/ReactFiberHotReloading.js` | L221-258 |
| `packages/react-reconciler/src/ReactFiberRoot.js` | L49-217 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberRootScheduler.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function scheduleTaskForRootDuringMicrotask" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L349-508 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L381-510 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L510-621 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L381-508 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L256-347 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L640-722 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L248-347 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L115-174 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L65-151 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L383-605 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L109-168 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L184-347 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L510-605 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L256-381 |
| `packages/react-reconciler/src/ReactFiberConfigWithNoMicrotasks.js` | L18-22 |

</details>
</tool-use>

---

我们现在位于 React 调度机制的核心腹地。

你看到的 `scheduleTaskForRootDuringMicrotask` (位于 `packages/react-reconciler/src/ReactFiberRootScheduler.js`) 是 React 如何决定“何时”以及“以什么优先级”执行代码的决策中心。

### 1. 优先级决策 (`getNextLanes`)

React 不会盲目地执行任务。它首先通过 `getNextLanes` 计算出当前最应该处理的任务：

```javascript
  const nextLanes =
    // ...
    : getNextLanes(
        root,
        root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
        rootHasPendingCommit,
    );
```
-   如果有更高优先级的任务插入（比如用户点击），`nextLanes` 会变成那个高优先级任务。
-   如果没有任务，`nextLanes` 为 `NoLanes`，React 会取消现有的 callback (`cancelCallback`)，以此节省资源。

### 2. 调度策略：复用 vs 替换

这是 React 调度的高明之处（约 462 行）：
```javascript
    if (
      newCallbackPriority === existingCallbackPriority
    ) {
      // 优先级没变，复用现有的调度任务
      return newCallbackPriority;
    } else {
      // 优先级变了（通常是变高了），取消旧任务，调度新任务
      cancelCallback(existingCallbackNode);
    }
```
**例子：** 假设 React 正在后台以“低优先级”渲染一个大列表。突然用户点击了一个按钮（“高优先级”）。
1.  `ensureRootIsScheduled` 被调用。
2.  `getNextLanes` 发现高优先级任务。
3.  `newCallbackPriority` (高) !== `existingCallbackPriority` (低)。
4.  React 取消低优先级的后台任务。
5.  立即调度一个新的高优先级任务。

### 3. 真正的调度 (`scheduleCallback`)

如果决定要调度一个新任务，React 会调用 `Scheduler` (约 500 行)：

```javascript
    const newCallbackNode = scheduleCallback(
      schedulerPriorityLevel,
      performWorkOnRootViaSchedulerTask.bind(null, root),
    );
```

这里注册的回调函数是 `performWorkOnRootViaSchedulerTask`。
当 Scheduler 决定轮到 React 执行时，它就会调用这个函数。

---

### 进入 WorkLoop

当 `performWorkOnRootViaSchedulerTask` 被执行时，它最终会调用 `performWorkOnRoot` (在 `ReactFiberWorkLoop.js` 中)。

这就是 **WorkLoop** 的入口。

请打开 `packages/react-reconciler/src/ReactFiberWorkLoop.js`，我们需要寻找 `renderRootSync` 和 `renderRootConcurrent` 这两个函数。它们是 React 渲染循环的两种模式。

**你的下一个探索任务：**
找到 `workLoopSync` 和 `workLoopConcurrent`。
看看它们有什么区别？（提示：关注 `shouldYield`）。

```javascript
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

这就是 React **时间切片 (Time Slicing)** 的秘密所在！

准备好看看这两个循环的真实代码了吗？

---

_**User (2026-01-05 18:46Z)**_

继续

---

_**Agent (model gemini-3-pro-preview, mode Ask)**_

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function workLoopSync" • **10** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L2531-4124 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L2513-4124 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L176-246 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L1813-2507 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L891-1321 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L512-638 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L409-461 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L1325-1757 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L1325-2507 |
| `packages/react-reconciler/src/ReactFiberRootScheduler.js` | L510-605 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberWorkLoop.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberWorkLoop.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberWorkLoop.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function workLoopConcurrent" • **11** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L2531-4124 |
| `packages/react-reconciler/src/ReactFiberConcurrentUpdates.js` | L51 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L891-1321 |
| `packages/react-reconciler/src/ReactFiberConcurrentUpdates.js` | L84-130 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L1813-2520 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L1325-1757 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L216-277 |
| `packages/react-reconciler/src/ReactFiberConcurrentUpdates.js` | L44-94 |
| `packages/react-reconciler/src/ReactFiberConcurrentUpdates.js` | L128-182 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L57-134 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L2513-4124 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberWorkLoop.js</summary>

</details>
</tool-use>

---

我们找到了 `workLoop` 的三种形态！

在 `packages/react-reconciler/src/ReactFiberWorkLoop.js` 中，React 针对不同的场景提供了不同的循环策略。

### 1. `workLoopSync` (同步循环)

```javascript
function workLoopSync() {
  // 只要还有工作没做完，就一直做下去，谁也别想打断我！
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```
这是最简单的模式。用于：
-   **Legacy Mode**: 老版本的 React。
-   **Discrete Updates**: 极短时间内的用户交互（如 `click`，`input`），为了保证响应速度，React 选择一气呵成。
-   **Expired Updates**: 如果一个任务饿死太久了，React 会强制用同步模式把它做完。

### 2. `workLoopConcurrentByScheduler` (调度器控制的并发循环)

```javascript
function workLoopConcurrentByScheduler() {
  // 只要还有工作，并且调度器说“还能继续”（没有超时且没有更高优先级任务），就继续做。
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```
这是我们常说的**时间切片 (Time Slicing)** 的经典实现。
-   `shouldYield()` 来自 `Scheduler` 包。它会检查：
    1.  当前分配的时间片（默认 5ms）是否用完了？
    2.  是否有更高优先级的任务（如用户输入）插队？
-   如果 `shouldYield()` 返回 `true`，循环终止。React 会保存当前的 `workInProgress` 指针，退出 `performWorkOnRoot`，把控制权交还给浏览器。

### 3. `workLoopConcurrent` (内部节流的并发循环)

这是 React 18+ 引入的一种新模式，用于微调帧率：

```javascript
function workLoopConcurrent(nonIdle: boolean) {
  if (workInProgress !== null) {
    // 如果不是空闲任务，每 25ms 让出一次；如果是空闲任务，每 5ms 让出一次。
    const yieldAfter = now() + (nonIdle ? 25 : 5);
    do {
      performUnitOfWork(workInProgress);
    } while (workInProgress !== null && now() < yieldAfter);
  }
}
```
这种模式似乎是为了在处理 Transition 或重试时，故意降低帧率（到 30fps），以防止长时间占用主线程导致高优先级任务（如动画）卡顿。

---

### 下一站：`performUnitOfWork`

不管用哪种循环，它们的核心都是调用 `performUnitOfWork`。

```javascript
function performUnitOfWork(unitOfWork: Fiber): void {
  // 1. beginWork: “递”阶段。创建子 Fiber 节点。
  next = beginWork(current, unitOfWork, entangledRenderLanes);

  unitOfWork.memoizedProps = unitOfWork.pendingProps;

  if (next === null) {
    // 2. completeUnitOfWork: “归”阶段。如果没有子节点了，就往回走。
    completeUnitOfWork(unitOfWork);
  } else {
    // 继续处理子节点
    workInProgress = next;
  }
}
```

这就是著名的**深度优先遍历 (DFS)** 算法在 React Fiber 树上的体现。

**现在，我们面临两个分支：**

1.  **深入 `beginWork`**: 看看组件是怎么被调用的？Hooks 是怎么执行的？Diff 算法（Reconciliation）是怎么对比新旧节点的？
2.  **深入 `completeWork`**: 看看 DOM 节点是怎么创建的？属性是怎么更新的？

作为高级前端工程师，我建议先攻克 **`beginWork`**，因为这是 React 业务逻辑最集中的地方。你意下如何？

---

_**User (2026-01-06 10:36Z)**_

好的

---

_**Agent (model gemini-3-pro-preview, mode Ask)**_

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function beginWork" • **13** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L4111-4155 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L4359-4416 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L4222-4293 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L209-280 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L4060-4118 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L2531-4124 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L51-141 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L3859-3958 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L1781-2166 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L1419-1533 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L58 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L4282-4363 |
| `packages/react-reconciler/src/ReactFiberWorkLoop.js` | L216-277 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberBeginWork.js</summary>

</details>
</tool-use>

---

我们已经进入了 `beginWork`，这是 Render 阶段的核心驱动函数。
它的主要任务是：**根据 Fiber 节点的类型 (Tag)，执行相应的更新逻辑，并返回下一个要处理的 Fiber 节点（子节点）。**

### `beginWork` 的核心流程

#### 1. 优化策略：Bailout (快速跳过)
React 在这里会进行大量的优化检查（约 4155-4188 行）：

```javascript
  if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    if (oldProps !== newProps || hasLegacyContextChanged()) {
      didReceiveUpdate = true; // Props 变了，必须更新
    } else {
      // Props 没变。检查是否有 State 更新或 Context 变化
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);
      if (!hasScheduledUpdateOrContext) {
        // 既没 Props 变化，也没 State/Context 更新 -> 完美，直接跳过！
        didReceiveUpdate = false;
        return attemptEarlyBailoutIfNoScheduledUpdate(...);
      }
    }
  }
```
这就是 `React.memo` 或者父组件重渲染但子组件 Props 没变时，React 能跳过子组件渲染的底层原因。

#### 2. 根据 Tag 分发处理
如果不能 Bailout，React 就会根据 `workInProgress.tag` 进入不同的处理分支：

```javascript
  switch (workInProgress.tag) {
    case FunctionComponent:
      return updateFunctionComponent(...);
    case ClassComponent:
      return updateClassComponent(...);
    case HostRoot:
      return updateHostRoot(...);
    case HostComponent:
      return updateHostComponent(...);
    // ... 其他类型
  }
```

---

### 下一步：探索 Function Component 的更新

因为现在大家主要都用 Hooks，我们重点看看 `updateFunctionComponent`。
这会把我们引向 **Hooks 的实现原理**。

**你的下一个探索任务：**
1.  找到 `updateFunctionComponent`。
2.  在其中寻找 `renderWithHooks` 的调用。
3.  这将是揭开 `useState`, `useEffect` 神秘面纱的入口。

你想看看 `updateFunctionComponent` 是怎么工作的吗？

---

_**User (2026-01-06 10:36Z)**_

继续

---

_**Agent (model gemini-3-pro-preview, mode Ask)**_

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function updateFunctionComponent" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L1419-1533 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L4222-4293 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L1401-1530 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L4282-4363 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L404-536 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L1794-2166 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L1380-1530 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L1119-1276 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L1421-1685 |
| `packages/react-reconciler/src/ReactFiberClassComponent.js` | L66 |
| `packages/react-reconciler/src/ReactFiberClassComponent.js` | L1000-1216 |
| `packages/react-reconciler/src/ReactFiberClassComponent.js` | L1000-1181 |
| `packages/react-reconciler/src/ReactFiberClassComponent.js` | L851-1181 |
| `packages/react-reconciler/src/ReactFiberClassComponent.js` | L213-525 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L536-803 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactFiberBeginWork.js</summary>

</details>
</tool-use>

---

我们在 `packages/react-reconciler/src/ReactFiberBeginWork.js` 中找到了 `updateFunctionComponent`。

这里的关键代码在第 1504 行：

```javascript
    nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );
```

这就是魔法发生的地方！`renderWithHooks` 是 React 函数式组件执行的“沙箱”。

### 深入 Hooks 原理 (Phase 5 提前预演)

虽然我们目前的计划是 Phase 2 (Render)，但既然到了这里，不看看 Hooks 的工作原理太可惜了。

请打开 `packages/react-reconciler/src/ReactFiberHooks.js`。这是 React 源码中最复杂也最精彩的文件之一。

在 `renderWithHooks` 中，React 做了一件极其重要的事情：**切换 Dispatcher**。

```javascript
export function renderWithHooks(...) {
  // 1. 清除当前正在工作的 Fiber 的副作用列表
  currentlyRenderingFiber = workInProgress;
  
  // 2. 根据是“挂载 (Mount)”还是“更新 (Update)”，设置不同的 Hooks 实现
  if (current !== null && current.memoizedState !== null) {
    // 这是一个更新过程
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdate;
  } else {
    // 这是一个挂载过程
    ReactCurrentDispatcher.current = HooksDispatcherOnMount;
  }

  // 3. 真正执行你的组件函数！
  let children = Component(props, secondArg);
  
  // 4. 重置
  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
  
  return children;
}
```

**为什么 `useState` 在组件第一次渲染时和更新时行为不一样？**
答案就在这里：React 在内部动态替换了 `useState` 的实现！
-   **Mount 时**: 调用 `mountState`。它会初始化 State，并创建一个 Hook 对象挂载到链表上。
-   **Update 时**: 调用 `updateState`。它会遍历 updateQueue，计算出最新的 State。

### 回到 Reconciliation

当 `renderWithHooks` 执行完毕，我们拿到了 `nextChildren`（即你组件返回的 JSX）。
接下来的任务是：**对比 `current.child` 和 `nextChildren`，决定如何更新 DOM。**

代码回到了 `updateFunctionComponent` 的最后一行 (约 1529 行)：

```javascript
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
```

`reconcileChildren` 就是大名鼎鼎的 **Diff 算法** 入口。

---

### 下一步：Diff 算法实战

Diff 算法的核心逻辑在 `packages/react-reconciler/src/ReactChildFiber.js` 中。

这里有两个主要的函数：
1.  `reconcileChildFibers`: 处理 Update 场景，会追踪副作用（Placement, Deletion 等）。
2.  `mountChildFibers`: 处理 Mount 场景，不追踪副作用（为了性能，统一在父节点处理）。

**思考题：**
React 的 Diff 算法被称为“单层 Diff (Single-pass Diffing)”。它有什么限制？它是如何通过 `key` 来优化列表更新的？

**你的下一步探索：**
请确认是否要进入 `ReactChildFiber.js` 深入研究 `reconcileChildFibers`，特别是它如何处理 Array 类型的 children（列表对比）。

---

_**User (2026-01-06 10:36Z)**_

继续

---

_**Agent (model default, mode Agent)**_



---


深入 Diff 算法的核心实现。


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function reconcileChildFibers" • **7** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactChildFiber.js` | L103-2085 |
| `packages/react-reconciler/src/ReactChildFiber.js` | L108-2104 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L322-402 |
| `packages/react-reconciler/src/ReactChildFiber.js` | L79 |
| `packages/react-reconciler/src/ReactChildFiber.js` | L2106-2179 |
| `packages/react-reconciler/src/ReactChildFiber.js` | L2100-2110 |
| `packages/react-reconciler/src/ReactFiberBeginWork.js` | L134-213 |

</details>
</tool-use>

---



---





---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactChildFiber.js</summary>

</details>
</tool-use>

---



---





---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactChildFiber.js</summary>

</details>
</tool-use>

---



---





---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "function updateSlot" • **1** results</summary>
            
| File | Lines |
|------|-------|
| `packages/react-reconciler/src/ReactChildFiber.js` | L103-2085 |

</details>
</tool-use>

---



---





---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "function placeChild" in "packages/react-reconciler/src/ReactChildFiber.js" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `packages/react-reconciler/src/ReactChildFiber.js` | `function placeChild(` | L511 |


</details>
</tool-use>

---



---





---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactChildFiber.js</summary>

</details>
</tool-use>

---



---





---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "function mapRemainingChildren" in "packages/react-reconciler/src/ReactChildFiber.js" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `packages/react-reconciler/src/ReactChildFiber.js` | `function mapRemainingChildren(` | L467 |


</details>
</tool-use>

---



---





---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/maorui/Documents/Dev/react-study/packages/react-reconciler/src/ReactChildFiber.js</summary>

</details>
</tool-use>

---



---


已梳理 React Diff 算法的核心实现。以下是总结：

## React Diff 算法深度解析

React 的 Diff 算法在 `reconcileChildrenArray` 中实现，采用**三阶段策略**，兼顾性能与正确性。

### 阶段一：顺序匹配（First Pass - 1205-1258 行）

React 首先尝试按顺序匹配新旧列表：

```javascript
for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
  const newFiber = updateSlot(
    returnFiber,
    oldFiber,
    newChildren[newIdx],
    lanes,
  );
  // ...
  lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
}
```

**关键点：**
- `updateSlot` 会检查 `key` 和 `type` 是否匹配
- 如果匹配，复用 Fiber；否则返回 `null`，进入慢速路径
- `placeChild` 判断是否需要移动（标记 `Placement` 标志）

**`placeChild` 的移动检测逻辑（511-539 行）：**
```javascript
const oldIndex = current.index;
if (oldIndex < lastPlacedIndex) {
  // 这个节点在旧列表中的位置，比上一个已放置节点的位置还要靠前
  // 说明它被移动了！标记为 Placement
  newFiber.flags |= Placement;
} else {
  // 位置没变，可以原地复用
  return oldIndex;
}
```

### 阶段二：快速路径（Fast Paths）

#### 2.1 新列表已遍历完（1260-1267 行）
```javascript
if (newIdx === newChildren.length) {
  // 新列表结束了，删除剩余的旧节点
  deleteRemainingChildren(returnFiber, oldFiber);
  return resultingFirstChild;
}
```

#### 2.2 旧列表已遍历完（1270-1299 行）
```javascript
if (oldFiber === null) {
  // 旧列表结束了，剩下的都是新插入的节点
  for (; newIdx < newChildren.length; newIdx++) {
    const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
    // ...
  }
}
```

### 阶段三：Map 查找（Slow Path - 1302-1362 行）

当顺序匹配失败时，React 使用 Map 进行查找：

```javascript
// 1. 将剩余的旧节点放入 Map
const existingChildren = mapRemainingChildren(oldFiber);

// 2. 遍历剩余的新节点，从 Map 中查找匹配
for (; newIdx < newChildren.length; newIdx++) {
  const newFiber = updateFromMap(
    existingChildren,
    returnFiber,
    newIdx,
    newChildren[newIdx],
    lanes,
  );
  // ...
}

// 3. 删除 Map 中未被使用的旧节点
existingChildren.forEach(child => deleteChild(returnFiber, child));
```

**`mapRemainingChildren` 的映射规则（467-500 行）：**
- 有 `key` 的节点：`Map<key, Fiber>`
- 无 `key` 的节点：`Map<index, Fiber>`

### 为什么需要 key？

**没有 key 的情况：**
```jsx
// 旧: [<div>A</div>, <div>B</div>]
// 新: [<div>B</div>, <div>A</div>]
```
React 会认为：
- 位置 0：`<div>A</div>` → `<div>B</div>`（更新内容）
- 位置 1：`<div>B</div>` → `<div>A</div>`（更新内容）

结果：两个 DOM 节点都被更新，而不是移动。

**有 key 的情况：**
```jsx
// 旧: [<div key="a">A</div>, <div key="b">B</div>]
// 新: [<div key="b">B</div>, <div key="a">A</div>]
```
React 会：
- 在 Map 中找到 `key="b"` 的节点，标记为移动到位置 0
- 在 Map 中找到 `key="a"` 的节点，标记为移动到位置 1

结果：两个 DOM 节点被移动，而不是更新内容。

### 性能优化要点

1. 单层 Diff：只比较同一层级的节点，不跨层级
2. 类型检查：`type` 不同直接替换，不尝试复用
3. Key 优化：有 key 时使用 Map 查找，避免 O(n²) 复杂度
4. 移动检测：通过 `lastPlacedIndex` 最小化 DOM 移动

---

### 下一步学习建议

现在你已经理解了：
- Phase 1: 初始化与 Fiber 架构
- Phase 2: Render 阶段（BeginWork + Diff 算法）

接下来可以探索：
- Phase 3: Commit 阶段（`completeWork` 如何创建 DOM，`commitRoot` 如何应用副作用）
- Phase 4: Scheduler 的详细实现（时间切片、优先级队列）
- Phase 5: Hooks 的完整实现（`useState`、`useEffect` 的链表结构）

你想先深入哪个方向？

---

_**User (2026-01-06 10:36Z)**_

先整理下整理Phase 2的核心要点并保存为md

---

_**Agent (model gemini-3-pro-preview, mode Agent)**_

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] 整理 Phase 2: Render 阶段核心要点并保存为 markdown

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: study/phase2-render-phase.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] 整理 Phase 2: Render 阶段核心要点并保存为 markdown

</details>
</tool-use>

---

Phase 2 的核心要点已经整理完毕，保存在 `study/phase2-render-phase.md` 中。文档详细涵盖了从 `updateContainer` 到 `Diff 算法` 的完整链路，包括关键源码位置、核心逻辑流程图以及常见面试题（如为什么需要 key）的深度解析。

现在，我们完成了：
1.  **Phase 1: 初始化与 Fiber 架构** (已掌握)
2.  **Phase 2: Render 阶段 (Reconciliation)** (已掌握)

接下来，我们可以根据你的兴趣，选择进入 Phase 3、4 或 5。

**推荐路线：**
-   如果想知道 DOM 究竟是什么时候被创建和插入的 -> **Phase 3: Commit 阶段**
-   如果想搞懂时间切片和调度的黑魔法 -> **Phase 4: Scheduler**
-   如果想彻底搞懂 Hooks 的闭包陷阱和底层链表 -> **Phase 5: Hooks**

你想先攻克哪一个堡垒？

---

_**User (2026-01-06 10:36Z)**_

针对Phase 2 生成闪卡

---

_**Agent (model gemini-3-pro-preview, mode Agent)**_

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] 整理 Phase 2: Render 阶段核心要点并保存为 markdown
- [-] 为 Phase 2 生成记忆闪卡

</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: study/flashcards/phase2-render-flashcards.md</summary>

**Chunk 1**
Lines added: 95, lines removed: 1

```diff
@@ -1,1 +1,95 @@
- 
+ # Phase 2: Render Phase 记忆闪卡
+ 
+ ## 基础概念
+ 
+ ### Q1: React 的 Render 阶段主要负责什么？
+ **A:** Render 阶段负责**创建 Fiber 树**和**Diff 算法**。
+ - 它是一个**纯计算**过程，不涉及 DOM 操作。
+ - 它是**可中断**的（在并发模式下），可以被高优先级任务打断。
+ - 它的产出是一棵标记了副作用（Flags）的 Fiber 树。
+ 
+ ---
+ 
+ ### Q2: 什么是双缓存 (Double Buffering) 机制？
+ **A:** React 在内存中同时维护两棵 Fiber 树：
+ 1.  **Current Tree**: 当前屏幕上显示的内容。
+ 2.  **WorkInProgress Tree**: 正在构建的新树。
+ Render 阶段在 WorkInProgress 树上进行，Commit 阶段完成后，通过指针切换 (&#96;root.current = workInProgress&#96;) 将其变为 Current 树。
+ 
+ ---
+ 
+ ## 调度与入口
+ 
+ ### Q3: &#96;updateContainer&#96; 的主要职责是什么？
+ **A:**
+ 1.  计算更新优先级 (&#96;Lane&#96;)。
+ 2.  创建 &#96;Update&#96; 对象（包含新的 React 元素）。
+ 3.  将 Update 加入队列（&#96;enqueueUpdate&#96;）。
+ 4.  请求调度（&#96;scheduleUpdateOnFiber&#96;）。
+ 
+ ---
+ 
+ ### Q4: 为什么并发模式下的 &#96;enqueueUpdate&#96; 不直接写入 Fiber 的队列？
+ **A:** 为了支持**并发渲染**。
+ - React 使用全局数组 &#96;concurrentQueues&#96; **暂存** Updates。
+ - 避免在渲染过程中直接修改正在被读取的队列，防止状态不一致。
+ - 在渲染开始前，通过 &#96;finishQueueingConcurrentUpdates&#96; 统一将 Update 刷入 Fiber 的真实队列。
+ 
+ ---
+ 
+ ## 工作循环 (WorkLoop)
+ 
+ ### Q5: &#96;workLoopSync&#96; 和 &#96;workLoopConcurrent&#96; 的核心区别是什么？
+ **A:**
+ -   **&#96;workLoopSync&#96;**: 同步循环。&#96;while(workInProgress !== null)&#96;。一旦开始，除非完成或报错，否则不停止。用于 Legacy 模式或高优先级离散更新。
+ -   **&#96;workLoopConcurrent&#96;**: 并发循环。&#96;while(workInProgress !== null &amp;&amp; !shouldYield())&#96;。每处理一个节点前，都会检查**时间片**是否用完或是否有更高优先级任务插队。
+ 
+ ---
+ 
+ ### Q6: 深度优先遍历 (DFS) 在 React 中是如何体现的？
+ **A:** 通过 &#96;performUnitOfWork&#96; 循环：
+ 1.  **递 (BeginWork)**: 沿着 &#96;child&#96; 指针向下，创建/更新子节点。
+ 2.  **归 (CompleteWork)**: 当没有子节点时，沿着 &#96;return&#96; 指针向上（或 &#96;sibling&#96; 向右），收集副作用，构建 DOM 树。
+ 
+ ---
+ 
+ ## BeginWork与Diff算法
+ 
+ ### Q7: &#96;beginWork&#96; 中的 Bailout（跳过优化）条件是什么？
+ **A:**
+ 1.  **Props 没变** (&#96;oldProps === newProps&#96;)。
+ 2.  **Context 没变**。
+ 3.  **没有计划内的更新** (&#96;!hasScheduledUpdateOrContext&#96;)。
+ 满足这些条件时，React 会直接克隆子节点，跳过该子树的 Diff 过程（即 &#96;React.memo&#96; 的原理）。
+ 
+ ---
+ 
+ ### Q8: &#96;renderWithHooks&#96; 在 Mount 和 Update 时有什么不同？
+ **A:** 它会切换 **Dispatcher**。
+ -   **Mount 时**: 使用 &#96;HooksDispatcherOnMount&#96;（调用 &#96;mountState&#96; 等）。初始化 Hook 链表。
+ -   **Update 时**: 使用 &#96;HooksDispatcherOnUpdate&#96;（调用 &#96;updateState&#96; 等）。遍历 UpdateQueue 计算新状态。
+ 
+ ---
+ 
+ ### Q9: React Diff 算法的三个阶段是什么？
+ **A:**
+ 1.  **First Pass (顺序匹配)**: 尝试按索引复用节点。如果 key 和 type 匹配，直接复用；否则进入阶段三。
+ 2.  **Fast Paths**:
+     -   如果新列表先遍历完 -&gt; 删除剩余旧节点。
+     -   如果旧列表先遍历完 -&gt; 插入剩余新节点。
+ 3.  **Slow Path (Map 查找)**: 将剩余旧节点存入 Map (&#96;key&#96; -&gt; &#96;Fiber&#96;)，然后遍历新节点，从 Map 中查找可复用的节点。
+ 
+ ---
+ 
+ ### Q10: 为什么列表渲染必须要 &#96;key&#96;？
+ **A:**
+ -   **没有 Key**: React 只能按索引对比。如果列表顺序发生变化（如 &#96;[A, B]&#96; -&gt; &#96;[B, A]&#96;），React 会认为是 A 变成了 B，B 变成了 A，导致不必要的**内容更新**，且无法复用 DOM 节点状态（如输入框焦点）。
+ -   **有 Key**: React 通过 Map 查找，能识别出是节点发生了**移动**（Move），从而复用 DOM 节点，只进行移动操作，性能更高且状态不丢失。
+ 
+ ---
+ 
+ ### Q11: 什么是 &#96;placeChild&#96; 中的移动检测逻辑？
+ **A:** React 维护一个 &#96;lastPlacedIndex&#96;（最后一个可复用节点在旧列表中的索引）。
+ -   遍历新列表时，如果当前旧节点的索引 (&#96;oldIndex&#96;) **小于** &#96;lastPlacedIndex&#96;，说明该节点在旧列表中位置靠前，但现在被挤到了后面，因此标记为 **Placement** (移动)。
+ -   否则，更新 &#96;lastPlacedIndex = oldIndex&#96;，节点保持原地不动。
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] 整理 Phase 2: Render 阶段核心要点并保存为 markdown
- [x] 为 Phase 2 生成记忆闪卡

</details>
</tool-use>

---



---



---


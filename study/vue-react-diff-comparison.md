# Vue vs React Diff 算法对比

## React Diff 流程

```mermaid
flowchart TD
    A[开始 Diff] --> B{根节点类型相同?}
    B -->|否| C[卸载旧树,挂载新树]
    B -->|是| D[进入协调阶段]
    
    D --> E[单节点 Diff]
    E --> F{有 key?}
    F -->|是| G[使用 key 匹配]
    F -->|否| I[按位置比较]
    
    G --> H[复用 Fiber 节点]
    I --> J{类型相同?}
    J -->|是| K[更新属性]
    J -->|否| L[替换节点]
    
    K --> M[递归 Diff 子节点]
    H --> M
    L --> M
    
    M --> N{时间切片到期?}
    N -->|是| O[中断,保存进度]
    N -->|否| P{还有子节点?}
    
    O --> Q[等待下次调度]
    Q --> M
    P -->|是| M
    P -->|否| R[完成 Diff]
    
    C --> R
```

## Vue Diff 流程

```mermaid
flowchart TD
    A[开始 Diff] --> B{根节点类型相同?}
    B -->|否| C[替换整个节点]
    B -->|是| D[进入 patch 阶段]
    
    D --> E{是数组子节点?}
    E -->|否| F[文本/单节点处理]
    E -->|是| G[列表 Diff]
    
    G --> H[双端比较开始]
    H --> I[头指针 oldStart]
    H --> J[尾指针 oldEnd]
    H --> K[头指针 newStart]
    H --> L[尾指针 newEnd]
    
    I --> M{oldStart === newStart?}
    M -->|是| N[复用节点,指针后移]
    M -->|否| O{oldEnd === newEnd?}
    
    O -->|是| P[复用节点,指针前移]
    O -->|否| Q{oldStart === newEnd?}
    
    Q -->|是| R[复用+移动节点]
    Q -->|否| S{oldEnd === newStart?}
    
    S -->|是| T[复用+移动节点]
    S -->|否| U[使用 key Map 查找]
    
    U --> V{找到匹配?}
    V -->|是| W[复用+移动]
    V -->|否| X[创建新节点]
    
    N --> Y{指针交叉?}
    P --> Y
    R --> Y
    T --> Y
    W --> Y
    X --> Y
    
    Y -->|否| M
    Y -->|是| Z[处理剩余节点]
    Z --> AA[完成 Diff]
    
    F --> AA
    C --> AA
```

## 核心设计差异对比

```mermaid
flowchart LR
    subgraph React["React Diff 特点"]
        R1[单节点逐个比较]
        R2[可中断/可恢复]
        R3[基于 Fiber 树]
        R4[时间切片]
        R5[递归深度优先]
    end
    
    subgraph Vue["Vue Diff 特点"]
        V1[双端比较算法]
        V2[同步一次性完成]
        V3[基于虚拟 DOM]
        V4[更激进的优化]
        V5[头尾指针遍历]
    end
    
    React --> Diff["Diff 策略"]
    Vue --> Diff
```

## 设计原因分析

### React 的设计哲学

1. **可中断性优先**
   - React 追求"时间切片"，让高优先级任务可以打断低优先级渲染
   - 单节点 Diff 便于在任意节点处暂停和恢复
   - 如果采用双端比较，中断后恢复状态会很复杂

2. **Fiber 架构的必然选择**
   - Fiber 节点本身就是为可中断设计的
   - 每个 Fiber 节点保存了"工作进度"，可以随时中断和恢复
   - 递归的深度优先遍历天然适合这种"保存现场"的机制

3. **渐进式优化**
   - React 的 Diff 策略相对保守，优先保证正确性
   - 通过 key 优化列表性能，但不会做过于激进的假设

### Vue 的设计哲学

1. **性能优先**
   - Vue 假设大多数场景下，列表的变更都是"局部调整"
   - 双端比较能快速处理"头部插入"、"尾部追加"等常见场景
   - 一次性完成，避免状态保存的开销

2. **同步渲染模型**
   - Vue 2/3 的响应式系统是同步的
   - 不需要考虑中断和恢复，可以放心使用更复杂的算法
   - 双端比较 + key Map 的组合能最大化复用率

3. **更激进的优化假设**
   - 假设用户会正确使用 key
   - 假设列表操作以"局部调整"为主
   - 通过更复杂的算法换取更好的平均性能

## 性能特征对比

| 场景 | React | Vue |
|------|-------|-----|
| 头部插入 | O(n) | O(1) |
| 尾部追加 | O(n) | O(1) |
| 中间插入 | O(n) | O(n) |
| 随机重排 | O(n) | O(n) |
| 可中断性 | ✅ | ❌ |
| 内存开销 | 较高(Fiber) | 较低(VDOM) |

## 思考题

**现在请你思考：如果 React 也采用 Vue 的双端比较算法，会带来什么问题？反过来，如果 Vue 采用 React 的可中断 Diff，又会遇到什么挑战？**
